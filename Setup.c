/*
 * Setup.cpp
 *
 *  Created on: 28-Aug-2014
 *      Author: nikhil
 */

/**
 * @Warning DO NOT EDIT THIS FILE!
 * This file contain function related to System driver initialization
 */

#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "ch.h"
#include "hal.h"
#include "chprintf.h"
#include "Setup.h"
#include "config/def.h"
#include "intercomm.h"

SerialUSBDriver SDU1;
/*
 * Endpoints to be used for USBD1.
 */
#define USBD1_DATA_REQUEST_EP           1
#define USBD1_DATA_AVAILABLE_EP         1
#define USBD1_INTERRUPT_REQUEST_EP      2

/*
 * USB Device Descriptor.
 */
static const uint8_t vcom_device_descriptor_data[18] = {
  USB_DESC_DEVICE       (0x0110,        /* bcdUSB (1.1).                    */
                         0x02,          /* bDeviceClass (CDC).              */
                         0x00,          /* bDeviceSubClass.                 */
                         0x00,          /* bDeviceProtocol.                 */
                         0x40,          /* bMaxPacketSize.                  */
                         0x0483,        /* idVendor (ST).                   */
                         0x5740,        /* idProduct.                       */
                         0x0200,        /* bcdDevice.                       */
                         1,             /* iManufacturer.                   */
                         2,             /* iProduct.                        */
                         3,             /* iSerialNumber.                   */
                         1)             /* bNumConfigurations.              */
};

/*
 * Device Descriptor wrapper.
 */
static const USBDescriptor vcom_device_descriptor = {
  sizeof vcom_device_descriptor_data,
  vcom_device_descriptor_data
};

/* Configuration Descriptor tree for a CDC.*/
static const uint8_t vcom_configuration_descriptor_data[67] = {
  /* Configuration Descriptor.*/
  USB_DESC_CONFIGURATION(67,            /* wTotalLength.                    */
                         0x02,          /* bNumInterfaces.                  */
                         0x01,          /* bConfigurationValue.             */
                         0,             /* iConfiguration.                  */
                         0xC0,          /* bmAttributes (self powered).     */
                         50),           /* bMaxPower (100mA).               */
  /* Interface Descriptor.*/
  USB_DESC_INTERFACE    (0x00,          /* bInterfaceNumber.                */
                         0x00,          /* bAlternateSetting.               */
                         0x01,          /* bNumEndpoints.                   */
                         0x02,          /* bInterfaceClass (Communications
                                           Interface Class, CDC section
                                           4.2).                            */
                         0x02,          /* bInterfaceSubClass (Abstract
                                         Control Model, CDC section 4.3).   */
                         0x01,          /* bInterfaceProtocol (AT commands,
                                           CDC section 4.4).                */
                         0),            /* iInterface.                      */
  /* Header Functional Descriptor (CDC section 5.2.3).*/
  USB_DESC_BYTE         (5),            /* bLength.                         */
  USB_DESC_BYTE         (0x24),         /* bDescriptorType (CS_INTERFACE).  */
  USB_DESC_BYTE         (0x00),         /* bDescriptorSubtype (Header
                                           Functional Descriptor.           */
  USB_DESC_BCD          (0x0110),       /* bcdCDC.                          */
  /* Call Management Functional Descriptor. */
  USB_DESC_BYTE         (5),            /* bFunctionLength.                 */
  USB_DESC_BYTE         (0x24),         /* bDescriptorType (CS_INTERFACE).  */
  USB_DESC_BYTE         (0x01),         /* bDescriptorSubtype (Call Management
                                           Functional Descriptor).          */
  USB_DESC_BYTE         (0x00),         /* bmCapabilities (D0+D1).          */
  USB_DESC_BYTE         (0x01),         /* bDataInterface.                  */
  /* ACM Functional Descriptor.*/
  USB_DESC_BYTE         (4),            /* bFunctionLength.                 */
  USB_DESC_BYTE         (0x24),         /* bDescriptorType (CS_INTERFACE).  */
  USB_DESC_BYTE         (0x02),         /* bDescriptorSubtype (Abstract
                                           Control Management Descriptor).  */
  USB_DESC_BYTE         (0x02),         /* bmCapabilities.                  */
  /* Union Functional Descriptor.*/
  USB_DESC_BYTE         (5),            /* bFunctionLength.                 */
  USB_DESC_BYTE         (0x24),         /* bDescriptorType (CS_INTERFACE).  */
  USB_DESC_BYTE         (0x06),         /* bDescriptorSubtype (Union
                                           Functional Descriptor).          */
  USB_DESC_BYTE         (0x00),         /* bMasterInterface (Communication
                                           Class Interface).                */
  USB_DESC_BYTE         (0x01),         /* bSlaveInterface0 (Data Class
                                           Interface).                      */
  /* Endpoint 2 Descriptor.*/
  USB_DESC_ENDPOINT     (USBD1_INTERRUPT_REQUEST_EP|0x80,
                         0x03,          /* bmAttributes (Interrupt).        */
                         0x0008,        /* wMaxPacketSize.                  */
                         0xFF),         /* bInterval.                       */
  /* Interface Descriptor.*/
  USB_DESC_INTERFACE    (0x01,          /* bInterfaceNumber.                */
                         0x00,          /* bAlternateSetting.               */
                         0x02,          /* bNumEndpoints.                   */
                         0x0A,          /* bInterfaceClass (Data Class
                                           Interface, CDC section 4.5).     */
                         0x00,          /* bInterfaceSubClass (CDC section
                                           4.6).                            */
                         0x00,          /* bInterfaceProtocol (CDC section
                                           4.7).                            */
                         0x00),         /* iInterface.                      */
  /* Endpoint 3 Descriptor.*/
  USB_DESC_ENDPOINT     (USBD1_DATA_AVAILABLE_EP,       /* bEndpointAddress.*/
                         0x02,          /* bmAttributes (Bulk).             */
                         0x0040,        /* wMaxPacketSize.                  */
                         0x00),         /* bInterval.                       */
  /* Endpoint 1 Descriptor.*/
  USB_DESC_ENDPOINT     (USBD1_DATA_REQUEST_EP|0x80,    /* bEndpointAddress.*/
                         0x02,          /* bmAttributes (Bulk).             */
                         0x0040,        /* wMaxPacketSize.                  */
                         0x00)          /* bInterval.                       */
};

/*
 * Configuration Descriptor wrapper.
 */
static const USBDescriptor vcom_configuration_descriptor = {
  sizeof vcom_configuration_descriptor_data,
  vcom_configuration_descriptor_data
};

/*
 * U.S. English language identifier.
 */
static const uint8_t vcom_string0[] = {
  USB_DESC_BYTE(4),                     /* bLength.                         */
  USB_DESC_BYTE(USB_DESCRIPTOR_STRING), /* bDescriptorType.                 */
  USB_DESC_WORD(0x0409)                 /* wLANGID (U.S. English).          */
};

/*
 * Vendor string.
 */
static const uint8_t vcom_string1[] = {
  USB_DESC_BYTE(8),                    /* bLength.                         */
  USB_DESC_BYTE(USB_DESCRIPTOR_STRING), /* bDescriptorType.                 */

  'A', 0, 'U', 0, 'S', 0
};

/*
 * Device Description string.
 */
static const uint8_t vcom_string2[] = {
  USB_DESC_BYTE(24),                    /* bLength.                         */
  USB_DESC_BYTE(USB_DESCRIPTOR_STRING), /* bDescriptorType.                 */

  'N', 0, 'A', 0, 'Y', 0, 'A', 0, 'N', 0, '-', 0, 'S', 0, 'L', 0, 'A', 0, 'V', 0, 'E', 0
};

/*
 * Serial Number string.
 */
static const uint8_t vcom_string3[] = {
  USB_DESC_BYTE(8),                     /* bLength.                         */
  USB_DESC_BYTE(USB_DESCRIPTOR_STRING), /* bDescriptorType.                 */
  '0' + '0', 0,
  '0' + '0', 0,
  '0' + '1', 0
};

/*
 * Strings wrappers array.
 */
static const USBDescriptor vcom_strings[] = {
  {sizeof vcom_string0, vcom_string0},
  {sizeof vcom_string1, vcom_string1},
  {sizeof vcom_string2, vcom_string2},
  {sizeof vcom_string3, vcom_string3}
};

/*
 * Handles the GET_DESCRIPTOR callback. All required descriptors must be
 * handled here.
 */
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
}

/**
 * @brief   IN EP1 state.
 */
static USBInEndpointState ep1instate;

/**
 * @brief   OUT EP1 state.
 */
static USBOutEndpointState ep1outstate;

/**
 * @brief   EP1 initialization structure (both IN and OUT).
 */
static const USBEndpointConfig ep1config = {
  USB_EP_MODE_TYPE_BULK,
  NULL,
  sduDataTransmitted,
  sduDataReceived,
  0x0040,
  0x0040,
  &ep1instate,
  &ep1outstate,
  2,
  NULL
};

/**
 * @brief   IN EP2 state.
 */
static USBInEndpointState ep2instate;

/**
 * @brief   EP2 initialization structure (IN only).
 */
static const USBEndpointConfig ep2config = {
  USB_EP_MODE_TYPE_INTR,
  NULL,
  sduInterruptTransmitted,
  NULL,
  0x0010,
  0x0000,
  &ep2instate,
  NULL,
  1,
  NULL
};
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
  extern SerialUSBDriver SDU1;

  switch (event) {
  case USB_EVENT_RESET:
    return;
  case USB_EVENT_ADDRESS:
    return;
  case USB_EVENT_CONFIGURED:
    chSysLockFromIsr();

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);

    /* Resetting the state of the CDC subsystem.*/
    sduConfigureHookI(&SDU1);

    chSysUnlockFromIsr();
    return;
  case USB_EVENT_SUSPEND:
    return;
  case USB_EVENT_WAKEUP:
    return;
  case USB_EVENT_STALLED:
    return;
  }
  return;
}
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
/*
 * USB driver configuration.
 */
const USBConfig usbcfg = {
  usb_event,
  get_descriptor,
  sduRequestsHook,
  NULL
};
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
/*
 * Serial over USB driver configuration.
 */
const SerialUSBConfig serusbcfg = {
  &USBD1,
  USBD1_DATA_REQUEST_EP,
  USBD1_DATA_AVAILABLE_EP,
  USBD1_INTERRUPT_REQUEST_EP
};

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
void StartTelemetry(void){

	sduObjectInit(&SDU1);
	sduStart(&SDU1, &serusbcfg);

	usbDisconnectBus(serusbcfg.usbp);
	chThdSleepMilliseconds(1000);
	usbStart(serusbcfg.usbp, &usbcfg);
	usbConnectBus(serusbcfg.usbp);

#if BOARD == NAYAN
	static SerialConfig telemetrycfg = {
			115200,
			0,
	        USART_CR2_STOP1_BITS | USART_CR2_LINEN,
	        0
	};

	sdStart(&SD2, &telemetrycfg);
	palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));
	palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
	delay(100);

	delay(3000);

#elif BOARD == V10
	static SerialConfig telemetrycfg = {
			115200,
			0,
	        USART_CR2_STOP1_BITS | USART_CR2_LINEN,
	        0
	};

	sdStart(&SD2, &telemetrycfg);
	palSetPadMode(GPIOD, 5, PAL_MODE_ALTERNATE(7));
	palSetPadMode(GPIOD, 6, PAL_MODE_ALTERNATE(7));
	delay(100);

	delay(3000);

#endif

}

void debug(const char *fmt, ...){

	chprintf((BaseSequentialStream *)&SD2, "%s", "Debug: ");
	va_list ap;
	va_start(ap, fmt);
	chvprintf((BaseSequentialStream *)&SD2, fmt, ap);
	va_end(ap);

	chprintf((BaseSequentialStream *)&SD2, "%s", "\r\n");

}
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
uint32_t millis(void){
	return ST2MS(chTimeNow());
}

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
#if BOARD == NAYAN
static const SPIConfig slvcfg = {
  NULL,
  GPIOA,
  4,
  0
};

#elif BOARD == V10
static const SPIConfig slvcfg = {
  NULL,
  GPIOB,
  12,
  0
};

#endif

/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
void start_intercomm(void){
	delay(15000);
#if BOARD == NAYAN
	palSetPadMode(GPIOA, 4, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
	palSetPad(GPIOA, 4);
	palSetPadMode(GPIOA, 5, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
	palSetPadMode(GPIOA, 6, PAL_MODE_ALTERNATE(5));
	palSetPadMode(GPIOA, 7, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
	delay(50);
	spiStart(&SPID1, &slvcfg);

#elif BOARD == V10
/*	palSetPadMode(GPIOB, 12, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);
	palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
	palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(5));
	palSetPadMode(GPIOB, 15, PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
	delay(50);*/
	spiStart(&SPID2, &slvcfg);
	palSetPad(GPIOB, 12);
	delay(50);

#endif
	delay(50);

}
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
void start_blink(void){
#if BOARD == NAYAN
	palSetPad(GPIOC, 0);
	palSetPad(GPIOC, 1);

	delay(500);
	palClearPad(GPIOC, 0);
	palClearPad(GPIOC, 1);

	delay(500);
	palSetPad(GPIOC, 0);
	palSetPad(GPIOC, 1);

	delay(500);
	palClearPad(GPIOC, 0);
	palClearPad(GPIOC, 1);
#elif BOARD == V10
	palSetPad(GPIOE, 0);
	palSetPad(GPIOE, 1);

	delay(500);
	palClearPad(GPIOE, 0);
	palClearPad(GPIOE, 1);

	delay(500);
	palSetPad(GPIOE, 0);
	palSetPad(GPIOE, 1);

	delay(500);
	palClearPad(GPIOE, 0);
	palClearPad(GPIOE, 1);
#endif
}
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
static WORKING_AREA(blinkerThread, 128);
static msg_t blinker(void *arg) {

  (void)arg;
  chRegSetThreadName("blinker");

  while (TRUE) {
#if BOARD == NAYAN
	  palTogglePad(GPIOC, 0);
#elif BOARD == V10
	  palTogglePad(GPIOE, 0);
#endif
	  delay(125);
  }
  return 0;
}
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
static WORKING_AREA(IC_Thread, 8192);
static msg_t IC_THD(void *arg) {
	(void)arg;
	chRegSetThreadName("IC_THD");

	uint16_t i = 0;

	bool new_data = FALSE;

	uint8_t stp = 0;

	bool_t sanity = FALSE;

	ic_rc_or_data.ic_rc.rc1 = 1500;
	ic_rc_or_data.ic_rc.rc2 = 1500;
	ic_rc_or_data.ic_rc.rc3 = 1000;
	ic_rc_or_data.ic_rc.rc4 = 1500;
	ic_rc_or_data.ic_rc.rc5 = 1500;
	ic_rc_or_data.ic_rc.rc6 = 1500;
	ic_rc_or_data.ic_rc.rc7 = 1000;

	while (TRUE) {
		uint8_t txbuf[80], rxbuf[80];

		txbuf[0] = 0x00;
		txbuf[1] = 0x1E;
		txbuf[2] = 0x00;
		txbuf[3] = 0x1D;
		txbuf[4] = 0x00;

		for( i = 0; i < 36; i = i + 2){
			txbuf[i+5] = 0X00;
		}

		for(i = 0; i < 14; i++){
			txbuf[(i + 5)] = ic_rc_or_data.raw[i];
		}

		 spi_exchange_data(&INTERCOM_SPI, txbuf, rxbuf, 80);

		int16_t cnt = -1;
		for(i = 0; i < 89; i++){
			if(cnt >= 0 && cnt < 74){
				ic_imu_data.raw[cnt] = rxbuf[i];
			  cnt++;
			  new_data = TRUE;
			}

			else if((rxbuf[i] == IC_IMU_H) && stp == 0){
				stp++;
			}
			else if((stp == 1) && (rxbuf[i] == 0x2D)){
				cnt = 0;
				stp = 0;
			}
		}

/*		for(i == 0; i < 74; i++){
			ic_imu_data.raw[i] = rxbuf[i+2];
		}*/


		if(new_data && (!(ic_imu_data.ic_imu.gx == 0 && ic_imu_data.ic_imu.gy == 0 && ic_imu_data.ic_imu.gz == 0)) &&
		(check_ahrs_sanity(ic_imu_data.ic_imu.gx) && check_ahrs_sanity(ic_imu_data.ic_imu.gy) && check_ahrs_sanity(ic_imu_data.ic_imu.gz)) &&
		(check_acc_sanity(ic_imu_data.ic_imu.ax) && check_acc_sanity(ic_imu_data.ic_imu.ay) && check_acc_sanity(ic_imu_data.ic_imu.az)))sanity = TRUE;

		if(sanity)update_ic_data();

		sanity = FALSE;
		new_data = FALSE;

		delay(4);
  }
  return 0;
}
/**
 * @Warning DO NOT EDIT THIS FUNCTION!
 */
void start_sys(void){

	start_blink();

	StartTelemetry();

	start_intercomm();

	chThdCreateStatic(blinkerThread, sizeof(blinkerThread), NORMALPRIO-2, blinker, NULL);

	chThdCreateStatic(IC_Thread, sizeof(IC_Thread), NORMALPRIO, IC_THD, NULL);
}


